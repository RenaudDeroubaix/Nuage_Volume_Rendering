#version 430

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(rgba32f, binding = 0) uniform image3D img_out;

uniform float u_time;
uniform vec3 resolution;

//gl_LocalInvocationID
//gl_GlobalInvocationID
//gl_WorkGroupID

/////////////////////////////BRUIT WORLEY LYGIA LIB

// Paramètres de bruit de Worley
#ifndef FNC_WORLEY
#define FNC_WORLEY

#ifndef WORLEY_JITTER
#define WORLEY_JITTER 1.0
#endif

#ifndef WORLEY_DIST_FNC
#define WORLEY_DIST_FNC distEuclidean
#endif

#define RANDOM_SCALE vec4(443.897, 441.423, .0973, .1099)

// Distance euclidienne
float distEuclidean(vec3 a, vec3 b) { return distance(a, b); }

// Générateur aléatoire 3D
vec3 random3(vec3 p) {
    p = fract(p * RANDOM_SCALE.xyz);
    p += dot(p, p.yzx + 19.19);
    return fract((p.xxy + p.yzz) * p.zyx);
}

// Calcul du bruit de Worley en 3D
vec2 worley2(vec3 p) {
    vec3 n = floor(p);  // Cellule actuelle
    vec3 f = fract(p);  // Position relative à l'intérieur de la cellule

    float distF1 = 1.0; // Première distance minimale
    float distF2 = 1.0; // Deuxième distance minimale
    vec3 off1 = vec3(0.0);
    vec3 pos1 = vec3(0.0);
    vec3 off2 = vec3(0.0);
    vec3 pos2 = vec3(0.0);

    // Parcours des cellules voisines
    for (int k = -1; k <= 1; k++) {
        for (int j = -1; j <= 1; j++) {
            for (int i = -1; i <= 1; i++) {
                vec3 g = vec3(i, j, k);                     // Offset de la cellule voisine
                vec3 o = random3(n + g) * WORLEY_JITTER;   // Position aléatoire dans la cellule
                vec3 p = g + o;                            // Position globale
                float d = WORLEY_DIST_FNC(p, f);           // Distance

                if (d < distF1) {
                    distF2 = distF1;
                    distF1 = d;
                    off2 = off1;
                    off1 = g;
                    pos2 = pos1;
                    pos1 = p;
                } else if (d < distF2) {
                    distF2 = d;
                    off2 = g;
                    pos2 = p;
                }
            }
        }
    }

    return vec2(distF1, distF2); // Retourne les deux distances minimales
}

// Génère un bruit de Worley basé sur la première distance
float worley(vec3 p) {
    return 1.0 - worley2(p).x;
}

#endif


void main() {
    // Coordonnées globales dans la texture
    ivec3 coords = ivec3(gl_GlobalInvocationID);

    // Dimensions du bruit
    vec3 u_resolution = resolution;

    // Normaliser les coordonnées pour rester entre 0 et 1
    vec3 st = vec3(coords) / u_resolution;

    // Calcul du bruit de Worley en 3D
    vec2 d = worley2(st * 10.0 + vec3(u_time));

    // Génération de la couleur basée sur le bruit
    vec4 color = vec4(vec3(1.0 - d.x), 1.0); // Inverser la distance pour un effet visuel



    // Stocker la couleur dans l'image 3D
    imageStore(img_out, coords, color);
}
